import asyncio
from openai.types.beta.threads import Run
from typing import Dict, Set

from utils import (
    get_client,
    store_files,
    create_assistant,
    to_messages,
    AsyncOpenAI,
    Assistant,
)


class QueryDispatcher:
    """Dispatch user queries to OpenAI API."""

    # attributes for interacting with the OpenAI API
    client: AsyncOpenAI
    assistant: Assistant
    # map chat ids to thread ids.
    threads: Dict

    # provide interface for the telegram bot to interact with
    # this class. `messages` and `responses` are queues of
    # Tuple[str, str] where the first value is a chat_id.
    queries: asyncio.Queue
    responses: asyncio.Queue
    chats: Set[str]
    handlers: Set[asyncio.Task]

    def __init__(self):
        self.client = get_client()
        self.queries = asyncio.Queue()
        self.responses = asyncio.Queue()
        self.chats = set()
        self.handlers = set()

    @classmethod
    async def setup(cls):
        qd = cls()

        # store information for the assistant in the VectorStore object
        # of the OpenAI API.
        batch = await store_files(qd.client)
        vectore_store_id = batch.vector_store_id

        # create an assistant.
        self.assistant = await create_assistant(qd.client, vectore_store_id)
        return qd

    async def thread_message(self, chat_id, text, role="user"):
        try:
            thread_id = self.threads[chat_id]
        except KeyError:
            thread_id = await self.create_thread(chat_id, text, role)
        await self.client.beta.threads.messages.create(
            thread_id, content=text, role=role
        )
        return thread_id

    async def create_thread(self, chat_id, text, role="user"):
        thread = await self.client.beta.threads.create(
            messages=to_messages(text, role)
        )
        thread_id = thread.id
        self.threads[chat_id] = thread_id
        return thread_id

    async def run_thread(self, thread_id) -> Run:
        # create a run and poll until it reaches a terminal state.
        run = await self.client.beta.threads.runs.create_and_poll(
            thread_id=thread_id,
            assistant_id=self.assistant.id,
        )
        return run

    async def get_response(self, run: Run):
        # if run is completed, retrieve the message it generated.
        if run.status == "completed":
            # retrieve a list of message objects in descending order
            # by default.
            messages = await self.client.beta.threads.messages.list(
                thread_id=run.thread_id,
                # limit to messages generated by a certain run.
                run_id=run.id,
            )
            response = messages.data[0].content[0].text.value
        else:
            response = f"Your query {run.status}."
        return response
